Semana 06
O componente sempre terá a estrutura de uma função e o export default dessa função.
O return será um componente HTML, mas só pode ser uma chave HTML principal com filhas dentro dela.
Para isso, podemos usar logo depois do return um <> e </> como HTML principal ou já o tipo que queremos,
 exemplo <footer>[conteúdo do componente aqui]</footer>, mas essa tag não será renderizada na tela, só o conteúdo interno.
O uso do componente da página será como se fosse um elemento novo <Footer></Footer>. Esse componente precisa ser importado
 com import. Exemplo: import Footer from './components/Footer.jsx' (normalmente o Intellisense importa sozinho)
Outra peculiaridade é o nome das classes. No HTML é class e no React é className
Yan recomenda sempre testar com um h1 ou h4 pra ver se o componente está sendo carregado
Base da aula: https://origamid.com/projetos/bikcraft

CSS
Para uma estilização global, ou seja, de todos os componentes; podemos colocar em index.css
Para estilizar um componente, criamos um arquivo com o nome do componente.css e importamos com import no componente
Exemplo: import './Footer.css'

Biblioteca de componentes (UI): https://www.radix-ui.com/ (mais completa)
Outra opção: https://mui.com/material-ui/

Início
- Instalar e configurar o node LST no computador
- Instalar vite: npm install -g vite
- Preparar projeto vite: npm create vite@latest
    nome do projeto (será criada uma pasta com esse projeto)
    React
    JavaScript
- Acessar a pasta criada
- Rodar: npm install para instalar dependências
- Rodar: npm run dev para iniciar o servidor com as configurações padrão e checar que está funcionando

Renderizar uma lista bikes criando um card através do componente CardBike pra cada item da lista:
{bikes.map(bike =>
    <CardBike key={bike.id} imagemSrc={bike.imgSrc} modelo={bike.modelo} preco={bike.preco}
    comprarBike={comprarBike} />
)}
OBS: Um componente ao ser renderizado em lista assim precisa ter uma propriedade key de identificação.

Em CardBike, a função recebe os parâmetros:
function CardBike({ modelo, preco, imagemSrc, comprarBike }) {...}

Sobre a função comprarBike como parâmetro:
const comprarBike = () => {
        console.log('Comprando a bike pelo Bicicletas.jsx')
    }
// Se usasse function comprarBike() {...}, em CardBike, no onClick, usaria {() => comprarBike()}


Semana 07
prop-types: https://www.npmjs.com/package/prop-types

------

const [resultado, setResultado] = useState(0)

    function handleAdd() {
        //setResultado(resultado + 1) //A atualização do estado leva um tempo. Quando colocamos várias atualizações em seguida, ele perde a referência e só executa a última chamada de atualização.
        //setResultado(resultado + 1)
        //setResultado(resultado + 3) //Só executaria essa última.
        //Testei chamando na do meio o setTimeout. Depois do tempo, ele atualizava o valor inicial para + 1, ignorando a mudança da última linha
        // Ou seja, a última linha transformou 0 em 3, mas um segundo depois transformava o 3 em 1.

        // Melhor trabalhar com estado anterior usando função de callback
        setResultado((estadoAnterior) => estadoAnterior + 1)
        setResultado((estadoAnterior) => estadoAnterior + 1)
        setResultado((estadoAnterior) => estadoAnterior + 1) //Usando a função de callback as 3 chamadas atualizam corretamente
    }

------

Ícones: https://heroicons.com/

------

Estilização inline com react em camelCase
<div style={{ marginBottom: 32, display: 'flex', gap: 16 }} //estilização inline com React

------

Json Placeholder: https://jsonplaceholder.typicode.com/posts/1

------

Exportação nomeada e/ou default
- Nomeada (Nicholas usa mais assim):
function Exemplo() {...}
export { Exemplo }

OU direto: export function Exemplo() {...}

Importação: import { Exemplo } from './...'

- Default (só tem uma por arquivo)(Yan usa mais assim)
function Exemplo() {...}
export default Exemplo

Importação: import Exemplo from './...'
OU chamando com qualquer nome: import OutroNome from './...' (importará a função default chamando ela de OutroNome dentro desse arquivo)

------

Exemplo de condicionais
className={isFocus ? 'input-focus' : ''} //Exemplo ternário. Obrigatório ter o 'else'. Abaixo outra forma
className={isFocus && 'input-focus'} //Alternativa: Condição verdadeira

Dá pra usar em elementos de tela também:
const [error, setError] = useState({
        error: false,
        message: ''
})

{error.error && (
    <span>Erro: {error.message}</span>
)}

------

useRef() ajuda a manipular a DOM acessando diretamente o elemento.
Exemplo de uso colocando focus no formulário:
const inputNameRef = useRef(null)

function handleSubmit(event) {
        event.preventDefault()
        console.log(inputNameRef.current.value) //Equivalente a "event.target.value", estamos pegando o elemento o qual estamos referenciando
        inputNameRef.current.value = "" //Isso vai mudar o valor na DOM sem renderizar novamente o componente
    }

useEffect(() => {
        if(inputNameRef.current) { //Porque pode acontecer dele vir nulo por questão de tempo de associação da referência
            inputNameRef.current.focus() //Como estamos pegando o elemento, podemos usar recursos javascript, como o focus
        }
    })

(...)
<form onSubmit={handleSubmit} className="form-container">
                <input ref={inputNameRef} type="text" placeholder="Informe seu nome" />
(...)

------
Aula 3
------
Quando precisa passar uma referência de pai para filho, precisa englobar o filho numa variável de função de callback (ao invés da function) e chamar outra função do React (forwardRef) para fazer essa passagem.
O forwardRef pede dois argumentos: forwardRef(props, ref).
Input2 está da forma que usamos até então e que não recebe a referência do componente.
Input3 é a solução com fazer o exemplo antes do 1:51

-------------------

Semana 8

------
Aula 1
------

Design atômico simplificado (metodologia de design de interfaces). O atômico realmente cria pastas chamadas "átomos", "células", etc.
No que estamos chamando de modelo simplificado, criamos uma pasta para "pages", uma página para "Componentes". Dentro de componentes criamos uma pasta para cada componente, assim podemos organizar o componente e seu CSS em um único lugar.

Instalar json-server: npm install json-server
https://www.npmjs.com/package/json-server

Criamos um arquivo chamado db.json e rodamos um servidor usando o json-server: json-server --watch db.json
Criamos o arquivo web.js para criar as funções que irão interagir com o banco de banco de dados.

------
Aula 2
------

Mencionado na aula, porque perguntaram, sobre o Bootstrap, bootstrap-react e tailwind. (nada aprofundado)

SPA - Renderiza tudo através de uma única página, o index. Tem formas de trabalhar pro usuário conseguir voltar, alterar url, etc.

ROTAS:
Usaremos o React Router: https://reactrouter.com
Instalação: npm i react-router-dom
Instalação de @types para ajudar durante desenvolvimento: npm install --save-dev @types/react-router-dom

Esse "as Router" é só pra apelidar, igual faço no PL SQL.
O BrowserRouter funcionará como uma espécie de switch case, verificando em qual condição a rota do navegador cai e exibindo a página certa.

Boilerplate:
import { Route, Routes, BrowserRouter as Router } from 'react-router-dom'

<>
<Router>
    <Routes>
        <Route path='/login' Component={SignIn} />
    </Routes>
</Router>
</>

------
Element e Component
<Route path='/login' Component={SignIn} />
<Route path='/cadastro' element={<SignUp />} />

Ambos fazem a mesma coisa (existem algumas diferenças), aí cada um se declara o componente de uma forma. Em termos de performance, o element é mais performático. O Component fica criando novas instâncias cada vez que é chamado.
Por isso, element é mais usado no mercado.

------

Exemplos de rotas e funções recebendo elementos:
function loginRedirect(componente) {
    if(isAuthenticated) {
      return <Navigate to={'/'} replace />
    }
    return componente
  }

------

Tag <Link> ou NavLink, a forma de substituir o <a href"">.
No React utilizamos o React Router. Se usar o <a>, ele quebra o fluxo do SPA por ficar chamando páginas diferentes.

import { Link } from "react-router-dom"
<Link to={'/'}>Home</Link>

------

Aula 3

------

Base para projeto e rotas:
import { Route, Routes, BrowserRouter as Router } from 'react-router-dom'

------

Boilerplate para projeto React: https://github.com/BrunoDVolpe/boilerplate_reactjs

------

Redirecionamento:

import { useNavigate } from 'react-router-dom';

 const navigate = useNavigate();

  function goToAbout() {
    navigate('/about');
  }

------

- App3 tem a primeira estrutura de página mestra / base para carregar automaticamente o header e sidebar.
- Tem também um modelo de rotas para separar as rotas em um arquivo e deixar o app apenas com o carregamento das telas.
- App.css, no final, tem exemplo com display grid

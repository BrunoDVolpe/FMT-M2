Semana 06
O componente sempre terá a estrutura de uma função e o export default dessa função.
O return será um componente HTML, mas só pode ser uma chave HTML principal com filhas dentro dela.
Para isso, podemos usar logo depois do return um <> e </> como HTML principal ou já o tipo que queremos,
 exemplo <footer>[conteúdo do componente aqui]</footer>, mas essa tag não será renderizada na tela, só o conteúdo interno.
O uso do componente da página será como se fosse um elemento novo <Footer></Footer>. Esse componente precisa ser importado
 com import. Exemplo: import Footer from './components/Footer.jsx' (normalmente o Intellisense importa sozinho)
Outra peculiaridade é o nome das classes. No HTML é class e no React é className
Yan recomenda sempre testar com um h1 ou h4 pra ver se o componente está sendo carregado
Base da aula: https://origamid.com/projetos/bikcraft

CSS
Para uma estilização global, ou seja, de todos os componentes; podemos colocar em index.css
Para estilizar um componente, criamos um arquivo com o nome do componente.css e importamos com import no componente
Exemplo: import './Footer.css'

Biblioteca de componentes (UI): https://www.radix-ui.com/ (mais completa)
Outra opção: https://mui.com/material-ui/

Início
- Instalar e configurar o node LST no computador
- Instalar vite: npm install -g vite
- Preparar projeto vite: npm create vite@latest
    nome do projeto (será criada uma pasta com esse projeto)
    React
    JavaScript
- Acessar a pasta criada
- Rodar: npm install para instalar dependências
- Rodar: npm run dev para iniciar o servidor com as configurações padrão e checar que está funcionando

Renderizar uma lista bikes criando um card através do componente CardBike pra cada item da lista:
{bikes.map(bike =>
    <CardBike key={bike.id} imagemSrc={bike.imgSrc} modelo={bike.modelo} preco={bike.preco}
    comprarBike={comprarBike} />
)}
OBS: Um componente ao ser renderizado em lista assim precisa ter uma propriedade key de identificação.

Em CardBike, a função recebe os parâmetros:
function CardBike({ modelo, preco, imagemSrc, comprarBike }) {...}

Sobre a função comprarBike como parâmetro:
const comprarBike = () => {
        console.log('Comprando a bike pelo Bicicletas.jsx')
    }
// Se usasse function comprarBike() {...}, em CardBike, no onClick, usaria {() => comprarBike()}


Semana 07
prop-types: https://www.npmjs.com/package/prop-types

------

const [resultado, setResultado] = useState(0)

    function handleAdd() {
        //setResultado(resultado + 1) //A atualização do estado leva um tempo. Quando colocamos várias atualizações em seguida, ele perde a referência e só executa a última chamada de atualização.
        //setResultado(resultado + 1)
        //setResultado(resultado + 3) //Só executaria essa última.
        //Testei chamando na do meio o setTimeout. Depois do tempo, ele atualizava o valor inicial para + 1, ignorando a mudança da última linha
        // Ou seja, a última linha transformou 0 em 3, mas um segundo depois transformava o 3 em 1.

        // Melhor trabalhar com estado anterior usando função de callback
        setResultado((estadoAnterior) => estadoAnterior + 1)
        setResultado((estadoAnterior) => estadoAnterior + 1)
        setResultado((estadoAnterior) => estadoAnterior + 1) //Usando a função de callback as 3 chamadas atualizam corretamente
    }

------

Ícones: https://heroicons.com/

------

Estilização inline com react em camelCase
<div style={{ marginBottom: 32, display: 'flex', gap: 16 }} //estilização inline com React

------

Json Placeholder: https://jsonplaceholder.typicode.com/posts/1

------

Exportação nomeada e/ou default
- Nomeada (Nicholas usa mais assim):
function Exemplo() {...}
export { Exemplo }

OU direto: export function Exemplo() {...}

Importação: import { Exemplo } from './...'

- Default (só tem uma por arquivo)(Yan usa mais assim)
function Exemplo() {...}
export default Exemplo

Importação: import Exemplo from './...'
OU chamando com qualquer nome: import OutroNome from './...' (importará a função default chamando ela de OutroNome dentro desse arquivo)

------

Exemplo de condicionais
className={isFocus ? 'input-focus' : ''} //Exemplo ternário. Obrigatório ter o 'else'. Abaixo outra forma
className={isFocus && 'input-focus'} //Alternativa: Condição verdadeira

Dá pra usar em elementos de tela também:
const [error, setError] = useState({
        error: false,
        message: ''
})

{error.error && (
    <span>Erro: {error.message}</span>
)}

------

useRef() ajuda a manipular a DOM acessando diretamente o elemento.
Exemplo de uso colocando focus no formulário:
const inputNameRef = useRef(null)

function handleSubmit(event) {
        event.preventDefault()
        console.log(inputNameRef.current.value) //Equivalente a "event.target.value", estamos pegando o elemento o qual estamos referenciando
        inputNameRef.current.value = "" //Isso vai mudar o valor na DOM sem renderizar novamente o componente
    }

useEffect(() => {
        if(inputNameRef.current) { //Porque pode acontecer dele vir nulo por questão de tempo de associação da referência
            inputNameRef.current.focus() //Como estamos pegando o elemento, podemos usar recursos javascript, como o focus
        }
    })

(...)
<form onSubmit={handleSubmit} className="form-container">
                <input ref={inputNameRef} type="text" placeholder="Informe seu nome" />
(...)

------
Aula 3
------
Quando precisa passar uma referência de pai para filho, precisa englobar o filho numa variável de função de callback (ao invés da function) e chamar outra função do React (forwardRef) para fazer essa passagem.
O forwardRef pede dois argumentos: forwardRef(props, ref).
Input2 está da forma que usamos até então e que não recebe a referência do componente.
Input3 é a solução com fazer o exemplo antes do 1:51
